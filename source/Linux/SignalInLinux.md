# Linux中的Signal

## 信号（signals）
信号是提供异步事件处理机制的软件中断，是进程间通信的主要方式。
不只是事件发生是异步的，信号处理也是异步的。

## 信号的生命周期
* 产生
* 内核存储
* 内核处理信号

## 信号处理方式
* 忽略（ignore）
* 处理 （handle）
handle又包括调用默认action和自定义action

## 信号标示符
头文件：`#include<signal.h>`
SIG*实质是一个正数，没有零，零代表 null signal

| Signal | Description | Default action
| - | - |
| SIGABRT | Sent by abort() | Terminate with core dump |
| SIGALRM | Sent by alarm() | Terminate
| SIGBUS | Hardware or alignment error | Terminate with core dump
| SIGCHLD | Child has terminated | Ignored
| SIGCONT | Process has continued after being stopped | Ignored
| SIGFPE | Arithmetic exception | Terminate with core dump
| SIGHUP | Process’s controlling terminal was closed (most frequently, the user logged out) | Terminate
| SIGILL | Process tried to execute an illegal instruction | Terminate with core dump
| SIGINT | User generated the interrupt character (Ctrl-C) | Terminate
| SIGIO | Asynchronous I/O event | Terminate^a
| SIGKILL | Uncatchable process termination | Terminate
| SIGPIPE | Process wrote to a pipe but there are no readers | Terminate
| SIGPROF | Profiling timer expired | Terminate
| SIGPWR | Power failure | Terminate
| SIGQUIT | User generated the quit character (Ctrl-\) | Terminate with core dump
| SIGSEGV | Memory access violation | Terminate with core dump
| SIGSTKFLT | Coprocessor stack fault | Terminate^b
| SIGSTOP | Suspends execution of the process | Stop
| SIGSYS | Process tried to execute an invalid system call | Terminate with core dump
| SIGTERM | Catchable process termination | Terminate
| SIGTRAP | Break point encountered | Terminate with core dump
| SIGTSTP | User generated the suspend character (Ctrl-Z) | Stop
| SIGTTIN | Background process read from controlling terminal | Stop
| SIGTTOU | Background process wrote to controlling terminal | Stop
| SIGURG | Urgent I/O pending | Ignored
| SIGUSR1 | Process-defined signal | Terminate
| SIGUSR2 | Process-defined signal | Terminate
| SIGVTALRM | Generated by setitimer()  when called with the ITIMER_VIRTUAL flag | Terminate
| SIGWINCH | Size of controlling terminal window changed | Ignored
| SIGXCPU | Processor resource limits were exceeded | Terminate with core dump
| SIGXFSZ | File resource limits were exceeded | Terminate with core dump
a The behavior on other Unix systems, such as BSD, is to ignore this signal.
b The Linux kernel no longer generates this signal; it remains only for backward compatibility.

这里边有31个信号标示符，看着就头大，总结几个常见的吧，然后其他再遇到的继续查 Linux System Programming。

* SIGINT    Crtl+C
* SIGKILL    process is forcefully terminated
* SIGABT    about()发出，接着进程终止并产生一个core file（这是什么？） 。在linux中，assert()之类的断言会调用about() 。一般这个错误经常遇到，主要是内存分配和释放错误，比如一个指针free了两次，然后assert时候就挂掉了。SIGABRT是中止一个程序，它可以被捕捉，但不能被阻塞。处理函数返回后，所有打开的文件描述符将会被关闭，流也会被flush。程序会结束，有可能的话还会core dump。 当程序调用abort(3)时，该进程会向自己发送SIGABRT信号。所以，SIGABRT一般用于信号中一些关键的处理，assert失败时也会使用它。不应该去捕捉SIGSEGV和SIGABRT信号，如果收到这种信号，说明进程处于一个不确定的状态，很可能会直接挂起。
* SIGSEGV This signal, whose name derives from segmentation violation, is sent to a process when it attempts an invalid memory access. This includes accessing unmapped memory, reading from memory that is not read-enabled, executing code in memory that is not execute-enabled, or writing to memory that is not write-enabled. Processes may catch and handle this signal, but the default action is to terminate the process and generate a core dump. 这个是经常遇到的非法访问内存错误，C++的内存操作还是要认真学习积累经验啊。
* SIGBUS 这个我没遇到过，不过有人说address alignment可能会导致SIGBUS，先放到这里，以后遇到再来总结。
